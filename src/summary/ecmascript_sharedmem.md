# 목차

1. **[TUTORIAL.md](#TUTORIAL.md)**

# TUTORIAL.md

## 공유 메모리 - 간단한 튜토리얼

### 동시 에이전트

브라우저 설정에서 공유 에이전트에 워커를 사용하는 것은 자연스러운 일입니다. 요약하자면 워커는 워커에서 실행할 스트립트의 URL을 `Worker` 객체에 할당하여 생성할 수 있습니다.

```js
var w = new Worker('myworker.js');
```

워커와 워커를 생성한 부모는 메시지 채널을 통해 통신합니다. 부모에서 `w.postMessage` 호출 시 워커에게 메시지를 보내고, 워커 객체의 핸들러는 메시지를 이벤트로 수신합니다.

```js
w.postMessage('hi'); // send "hi" to the worker
w.onmessage = function (ev) {
  console.log(ev.data); // prints "ho"
};
```

한편, 워커에서는 전역 핸들러가 메시지를 이벤트로 수신하고 전역 `postMessage` 함수를 호출하면 메시지를 부모에게 다시 보냅니다.

```js
onmessage = function (ev) {
  console.log(ev.data); // prints "hi"
  postMessage('ho'); // sends "ho" back to the creator
};
```

문자열뿐만 아니라 많은 유형의 데이터가 채널을 통해 전송될 수 있으며, 대상에 올바른 타입과 구조로 도착합니다.

### 공유 메모리 할당 및 공유

공유 메모리를 할당하려면 SharedArrayBuffer를 할당하기만 하면 됩니다.

```js
var sab = new SharedArrayBuffer(1024); // 1KiB shared memory
```

부모는 표준 `postMessage` 메서드을 사용하여 워커에게 메모리를 전송하여 워커와 이 메모리를 공유할 수 있습니다 .

```js
w.postMessage(sab);
```

작업자에서 이 개체는 이벤트의 데이터 속성으로 수신됩니다.

```js
var sab;
onmessage = function (ev) {
  sab = ev.data; // 1KiB shared memory, the same memory as in the parent
};
```

메모리는 임의의 에이전트에서 생성한 후 다른 에이전트와 공유할 수 있으며 여러 에이전트 간에 동시에 공유할 수 있습니다.

### 공유 메모리에 뷰 생성

SharedArrayBuffer는 공유되는 메모리를 제외하면 ArrayBuffer와 같으며 ArrayBuffer의 메모리와 동일한 방식으로 메모리에 접근합니다. 버퍼에 뷰를 생성한 다음 표준 배열 액세스 구문을 사용하여 뷰(view)를 통해 메모리에 액세스합니다. Int8Array에서 Float64Array까지 ArrayBuffer와 동일한 뷰 타입을 SharedArrayBuffer에 적용할 수 있습니다.

공유 메모리의 부모가 해당 배열을 수정할 의도 없이 워커와 큰 소수 배열을 공유하려고 한다고 가정합니다. 메모리를 할당하고 채우고 보냅니다.

```js
var sab = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT * 100000); // 100000 primes
var ia = new Int32Array(sab); // ia.length == 100000
var primes = new PrimeGenerator();
for (let i = 0; i < ia.length; i++) ia[i] = primes.next();
w.postMessage(ia);
```

워커는 전송된 Int32Array를 수신합니다.

```js
var ia;
onmessage = function (ev) {
  ia = ev.data; // ia.length == 100000
  console.log(ia[37]); // prints 163, the 38th prime
};
```

### 공유 메모리 업데이트 및 가시성

메모리가 실제로 공유되기 때문에 한 에이전트의 쓰기는 해당 메모리를 공유하는 다른 모든 에이전트에서 관찰됩니다.

```js
console.log(ia[37]); // Prints 163
ia[37] = 123456;
```

쓰기 작업을 실행한 에이전트에서 할당이 발생한 후, 잠시 후 변경 사항이 다른 에이전트에 표시됩니다.

```js
console.log(ia[37]); // Prints 123456, maybe, eventually
```

공유 메모리의 가장 까다로운 측면 중 하나는 쓰기 작업이 한 에이전트에서 다른 에이전트로 전파되는 데 걸리는 시간을 알기 어렵다는 것입니다. CPU, 운영 체제, 브라우저 및 실제로 쓰기 및 읽기 시 시스템에서 발생하는 다른 모든 것을 포함하는 시스템의 매우 광범위한 정의에 대해 실제로 작업이 발생하는 속도는 시스템에 따라 다릅니다.

사실, 추가 *동기화*가 없으면 위의 프로그램은 잘 정의되지 않습니다. (충돌하지는 않지만 읽기를 수행하는 에이전트는 163 및 123456 이외의 다른 값을 관찰할 수 있습니다. 이는 직관적이지 않지만 발생할 수 있습니다.) 동기화는 다음에 설명된 원자성 작업을 사용하여 구현됩니다.

### 원자성 작업

`Atomics`이라고 불리는 새로운 전역 객체는 여러 가지 새로운 *원자성 작업*을 정적 메서드로 제공합니다. 원자성 작업은 여러 관련 용도로 사용됩니다.

### 예측 가능한 값을 쓰고 읽기

원자 쓰기로 작성된 배열 요소의 원자 읽기는 쓰기 전에 셀에 있던 값 또는 쓰여진 값만 관찰합니다.

위의 예에서 작성자가 원자 쓰기를 사용하는 경우:

```js
console.log(ia[37]); // Prints 163, the 38th prime
Atomics.store(ia, 37, 123456);
```

그런 다음 값을 읽을 경우 값이 변경될 때까지 기다리기 위해 루프에서 원자 읽기를 사용할 수 있으며 일단 변경되면 예상대로 변경됩니다.

```js
while (Atomics.load(ia, 37) == 163);
console.log(ia[37]); // Prints 123456
```

#### 원자적 작업으로 순서 지정

원자적 읽기가 값을 관찰하면 기록기가 관찰된 쓰기를 수행하기 전에 수행한 다른 모든 쓰기(원자적이든 아니든)도 관찰 가능하다는 보장이 있습니다.

그것이 사실이 아닐 수도 있다는 것은 직관적이지 않지만 일어날 수 있습니다. 작가가 다음과 같이 한다고 가정합니다.

```js
ia[42] = 314159; // was 191
ia[37] = 123456; // was 163
```

다른 작업자가 이 두 값을 읽는다고 가정합니다.

```js
console.log(ia[37]);
console.log(ia[42]);
```

판독기는 123456 및 191을 인쇄할 수 있지만 그렇게 되지 않아야 합니다. 그 이유는 쓰기가 컴파일러와 (더 자주) CPU에 의해 재정렬될 수 있기 때문입니다.

원자성 연산은 프로그램에서 순서 포인트를 생성합니다. ia[37]이 원자적으로 작성되는 경우 원자 쓰기 이전에 수행된 모든 쓰기는 ia[37]에 대한 쓰기가 관찰되기 전까지 관찰 가능합니다.

```js
ia[42] = 314159; // was 191
Atomics.store(ia, 37, 123456); // was 163
```

```js
while (Atomics.load(ia, 37) == 163);
console.log(ia[37]); // Will print 123456
console.log(ia[42]); // Will print 314159
```

(마찬가지로 읽기가 순서 없이 수행될 수 있습니다. 원자성 작업도 읽기 순서를 지정합니다.)

#### 원자성 작업은 중단할 수 없습니다

원자적 읽기-수정-쓰기 작업은 수정된 값이 다시 기록될 때까지 다른 쓰기가 발생하지 않도록 보장합니다.

두 에이전트가 증가해야 하는 ia[112]의 공유 메모리에 카운터가 있다고 가정합니다. 명백한 값으로 증가시키면 `ia[112]++`둘 다 동시에 그렇게 할 위험이 있으며 업데이트가 손실될 수 있습니다(그리고 결과 값이 쓰레기가 될 수 있음). 그 이유는 증분을 수행하기 위해 CPU가 값을 로드하고 여기에 1을 더한 다음 다시 저장해야 하기 때문입니다. 그 사이에 다른 CPU가 같은 일을 했을 수도 있습니다.

대신 `Atomics.add(ia, 112, 1)`를 사용하면 경합이 발생하지 않도록 보장할 수 있습니다. 각 CPU는 중단되지 않고 개별적으로 로드, 추가 및 저장되며 카운터는 올바르게 업데이트됩니다.

#### 원자적 작업 연산

다음 작업은 `array`가 Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array 또는 Uint32Array일 때 사용할 수 있습니다.

| 연산                                          | 기능                                                                                      |
| --------------------------------------------- | ----------------------------------------------------------------------------------------- |
| load(array, index)                            | array[index]의 값을 반환                                                                  |
| store(array, index, value)                    | array[index]에 값 저장, 반환 값                                                           |
| compareExchange(array, index, oldval, newval) | array[index] == oldval이면 newval을 array[index]에 저장하고 array[index]의 이전 값을 반환 |
| exchange(array, index, value)                 | array[index]에 값을 저장하고 array[index]의 이전 값을 반환                                |
| add(array, index, value)                      | array[index]에 값을 추가하고 array[index]의 이전 값을 반환                                |
| sub(array, index, value)                      | array[index]에서 값을 빼고 array[index]의 이전 값을 반환                                  |
| and(array, index, value)                      | 논리곱 값을 array[index], array[index]의 이전 값 반환                                     |
| or(array, index, value)                       | 논리합 값을 array[index]로, array[index]의 이전 값을 반환                                 |
| xor(array, index, value)                      | 배타적 논리합 값을 array[index]로, array[index]의 이전 값을 반환                          |

### 작업이 일어나길 기다리기

위의 예에서 한 에이전트는 다른 에이전트가 값을 변경할 때까지 루프를 사용했습니다. 변경은 에이전트가 대기를 중단하고 다음에 해야 할 일을 계속 진행할 수 있다는 신호입니다.

이러한 *회전 루프*는 대기 시간이 매우 짧지 않는 한 컴퓨터 시간을 잘못 사용합니다. 대신 대기 중인 에이전트는 스스로를 절전 모드로 전환할 수 있으며 대신 다른 에이전트에 의해 명시적으로 깨울 수 있습니다. Atomics 개체는 두 메서드 `wait` 및 `wake` 에서 이를 위한 기본 메커니즘을 제공합니다.

이 예에서 쓰기 에이전트는 이제 다음을 수행합니다.

```js
console.log(ia[37]); // Prints 163
Atomics.store(ia, 37, 123456);
Atomics.wake(ia, 37, 1);
```

읽기 에이전트는 다음을 수행합니다.

```js
Atomics.wait(ia, 37, 163);
console.log(ia[37]); // Prints 123456
```

이것이 작동하는 방식은 일단 쓰기를 수행하면 쓰기 에이전트가 위치 ia[37]에서 잠자고 있는 한 에이전트를 깨우도록 요청한다는 것입니다. 한편, 읽기 에이전트는 ia[37]의 값이 여전히 163인 경우 잠자기를 요청합니다. 따라서 쓰기 에이전트가 이미 쓰기를 수행한 경우 읽기 에이전트는 계속 진행하고, 그렇지 않으면 잠자고 대기하며 깨어날 때까지 기다립니다.

### 추상화

실제로 일부 공유 메모리 기능, 특히 `wait` 및 `wake`는 정확하고 효율적으로 사용하기 어려울 수 있습니다. 따라서 사용을 단순화하기 위해 이들 주위에 추상화(JavaScript에서)를 구축하는 것이 유용합니다. 예를 들어 데모에서 전통적인 뮤텍스와 조건 변수를 찾을 수 있습니다. 이는 간단한 원자 값의 컨테이너이며 업데이트 대기 기능이 내장된(그리고 효율적인) 소위 "동기적" 객체입니다.

### 미묘함과 실용적인 조언

(추가 주제: 경쟁 조건, 교착 상태, flatjs?, 웹 API 및 공유 메모리.)

#### 브라우저의 기본 스레드에서 차단

브라우저의 메인 스레드에서 대기하는 것에 대해 본질적으로 문제가 있는 것은 없습니다. `wait`는 웨이크업 플래그가 설정되기를 기다리는 루프와 동일한 의미를 갖습니다. 그러나 대기 시간이 짧을 것이라는 보장이 없는 한 그러한 대기를 피하고 대신 메인 스레드를 대신하여 작동하고 메시지 전달을 사용하여 메인 스레드와 통신하는 "마스터 워커"를 두는 것이 좋습니다. "마스터 워커"는 브라우저의 응답성에 영향을 주지 않고 무기한 기다릴 수 있습니다.

해당 패턴의 변형은 마스터 워커가 필요하지 않지만 일부 조건이 충족될 때 마스터에게 메시지를 보내는 것에 대해 워커가 서로 조정하는 제어 구조입니다. 데모 섹션의 "비대칭 장벽"이 그러한 제어 구조입니다.

이 사양은 브라우저가 `wait`를 기본 스레드에서 거부할 수 있도록 허용하며 대부분의 브라우저가 결국 그렇게 할 것으로 예상됩니다. `wait`가 거부된 경우 예외가 발생합니다.

#### 원자적 액세스와 비원자적 액세스를 혼합하지 마십시오

원자적 액세스와 비원자적 액세스를 모두 사용하여 동일한 배열 요소에 안전하게 액세스하는 것이 확실히 가능하지만 일반적으로 제한된 상황에서만 가능합니다. 실제로 주어진 공유 배열 요소가 원자적으로 또는 비원자적으로 액세스되는 것이 가장 좋습니다. 원자적 요소는 동기화 변수 및 간단한 통신 채널로 사용되어야 하며, 비원자적 요소는 더 많은 양의 데이터에 사용될 수 있습니다.

#### 공유 메모리 비용

SharedArrayBuffer는 얼마나 비쌉니까? 현재 Firefox 구현에서는 공유 메모리를 사용하는 가장 쉬운 방법이 몇 개의 여러 뷰를 사용하여 응용 프로그램에 의해 분할되는 상당히 큰 공유 개체입니다. (어떤 의미에서 이것은 에이전트 간에 공유 객체를 전송하는 것이 어색하기 때문에 자기 충족적 예언입니다) 다른 구현에서는 작은 객체(예: 공유 응용 프로그램 객체당 하나)의 사용을 장려하는 다른 전략을 선택할 수 있습니다.

### 현재 구현에 대한 참고 사항(2016년 1월)

Firefox와 Chrome은 모두 제안된 API를 구현합니다.

- Firefox에서 API는 Nightly에서 기본적으로 활성화되며 Firefox 46부터는 에서 javascript.options.shared_memorytrue로 설정하여 Aurora, Developer Edition, Beta 및 Release에서 활성화할 수 있습니다 about:config. waitFirefox는 기본 스레드에서 거부합니다.
- Chrome에서 API는 기본적으로 꺼져 있으며 명령줄 옵션으로 활성화할 수 있습니다(문서화 예정).

Firefox에는 기본적으로 20개로 설정된 작업자 수에 대한 도메인당 제한이 있습니다. 한도를 초과하면 도메인의 새 작업자가 생성되지만 시작되지 않은 상태로 유지됩니다. wait시작되지 않은 작업자에 있는 프로그램은 일반적으로 교착 상태가 됩니다. (아마도 제한은 WebWorkers 사양을 위반하는 것입니다. 이를 명확히 하는 것을 목표로 하는 이 WHATWG 버그를 참조하십시오 .)
